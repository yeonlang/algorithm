# 삼성 A형 문제해결 전략



## 백트래킹

```
 완전 탐색의 경우 2차원 배열을 탐색하는 경우가 많이 나온다. 이때 여러가지 조건을 주게 되는데 보통 이 조건 모두를 테스트 해야하는 경우가 많아 조합이나 순열 등의 경우의 수를 찾아보게 된다. 
 이때 백트래킹을 사용하는 것이 주요 전략이라고 할 수 있는데 그 이유는 다음과 같다.
 
1. 순열의 시간복잡도가 제한시간을 초과할 때 가지치기를 사용하여 이용하여 탐색시간을 줄일 수 있다.
2. DP를 함께 구현하기에 용이하며 재귀를 이용하기 때문에 코드에 적용하기가 쉽다.
3. 재귀를 이용하기 때문에 코드가 짧고, 구조를 파악하기가 쉽다.
(특히 삼성의 경우 제한 시간을 여유롭게 주기 때문에 아무 생각없이 익숙하게 구현만 해도 맞는 경우가 많다.)

 다만 빠르게 구성하였는데 답이 틀리게 나오고 경우의 수가 너무 복잡할 경우 백트래킹은 디버깅이 힘들 수 있기 때문에 시간복잡도를 생각해보고 완전탐색이 가능하다면 stack이나 queue를 쓰는 BFS,DFS로 빠르게 변경해 보는 것도 좋다.
 
ex: 등산로조성, 숫자만들기, 연구소(백준), 디저트카페, 요리사, 보호필름, 엑시노스, 감시(백준) 등
```



## BFS

```python
 다차원 배열을 탐색할때 백트래킹을 이용한 완전탐색 구현 이외에는 무조건 BFS를 사용한다. 그 이유는 BFS는 모든지점 방문과 각 방문지점까지의 거리를 한번에 계산할 수 있지만 DFS는 모든지점을 방문하는 것 이외에는 할 수 없기 때문이다. 
    
ex: 아기상어(백준), 연구소(백준), 탈주범 검거 등 
```



## 이차원 dir 구현

```python
 기본적으로 상하좌우를 dx,dy를 이용하여 많이 구현하고는 한다. 그런데 몇몇 문제에서는 주어지는 조건에 따라 갈 수 있는 방향이 달라지는 경우가 있다. 이때 이차원 dy,dx를 통하여 다음과 같이 구현해 볼 수 있다.

백준의 파이프 문제를 예를 들면 다음과 같다. 
각 조건에 맞는 방향을 2차원 dy,dx 로 구현한다.
dy = [[0,1],[1,1],[0,1,1]]
dx = [[1,1],[0,1],[1,0,1]]

각 인덱스마다 갈 수 있는 방향의 갯수가 다르기 때문에 이것을 조절하기 위한 1차원 배열을 만들어준다.
nowdir = [2,2,3]

이렇게 갈 수 있는 방향이 특정되면 다음과 같이 현재의 방향(d)에 따라 다음 갈 방향이 어디인지 탐색할 수 있다.
for i in range(nowdir[d]):
	ny = y+dy[d][i]
	nx = x+dx[d][i]
    
ex: 감시(백준), 탈주범 검거, 파이프 등 

```



## 우선순위 구현

```tex
파이썬의 sorting 함수는 일반적으로 nlogn의 시간복잡도를 가진다. 하지만 배열의 크기가 작다면 위의 시간복잡도는 의미가 없어지기 때문에 key값을 이용한 sorting으로 매우 편하게 원하는 순서대로 배열을 정렬할 수 있다. 또한 복잡한 완전탐색에서 우선순위 queue를 임시로 구현하여 다음 탐색지점이나 다음 행동순서를 정한다면 문제의 깔끔한 풀이가 떠오르지 않을 때에도 답을 구현하는 데에는 성공할 수 있기 때문에 매우 유용한 테크닉이다. 

ex: 줄기세포, 차량정비소, 아기상어 등
```



## 2차원 배열의 업데이트

```
 벽돌을 부숴서 새롭게 배열을 정렬하거나, 삼성의 활주로 문제처럼 한 배열을 탐색해서 활주로를 건설할 수 있는지 판단할 때에 일반적인 생각으로 바로 접근하게 되면 매우 비효율적인 시간복잡도를 구현하는 경우가 있다. 
 이때 cnt 개념을 이용 하여 cnt 배열을 만들어주고 cnt를 한번 읽어오는 것을 구현하는 것은 (시간복잡도 O(n)) 이기 때문에 이를 이용한다면 조금 더 빠르고 편하게 원하는 바를 실행할 수 있다.
 
 ex: 벽돌깨기, 블록사목(3월 sw A모의 문제) , 활주로
```



## 시뮬레이션

 ```
간단한 시뮬레이션은 상관없지만 좌표값에 2개 이상의 정보가 담기는 경우, 부딪치고 소멸하고 합쳐지는 등의 시뮬레이션이 필요할 시에는 클래스를 사용하는 것이 좋다. 파이썬은 리스트에 클래스 인스턴트를 담을 수 있고, 그것을 이용하여 어떤 조건이 만족되었을 시에 각 인스턴트 내부의 정보를 업데이트 하는 것이 실제 시뮬레이션을 하는데 있어 매우 유리하기 때문이다.
 ```



## 2차원 배열에서 거리에 따라 할 수 있는 행동이 정해질 때

```
 2차원적인 어떤 조건을 주고 거리에 따라 취할수 있는 행동이 달라지는 경우가 있다. 처음에는 보통 2차원 배열 자체를 전체 탐색하며 원하는 조건을 구현해 주려고 하는데, 이 경우에는 한번 구현에 이차원 배열을 한번 탐색하게 되어 매우 비효율적인 경우가 발생할 수 있다. 가끔 생기는 이러한 문제는 좌표를 저장하는 배열을 만들고 좌표값을 업데이트 하거나 좌표값과 다른 필요한 정보를 가지는 클래스를 구현하여, 좌표의 계산값으로 상태변화를 처리함으로 빠른 시간내에 해결할 수 있다. 
```









